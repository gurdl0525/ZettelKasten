아래 세가지 역할을 수행하는 함수이다.

1. 현재의 쓰레드에 새 이벤트 루프를 설정
2. 해당 이벤트 루프에서 인자로 넘어오는 코루틴을 태스크로 예약하여 실행
3. 해당 태스크의 실행이 완료되면 이벤트 루프 close

3.7 이전 버전의 asyncio.run() 내부 코드
```python
loop = asyncio.get_event_loop()
loop.run_until_complete(first_coroutine())
loop.close()
```

### 1. asyncio.get_event_loop()
현재 쓰레드에 설정된 이벤트 루프를 가져오는 함수
  
이벤트 루프가 없다면 새로 생성하여 현재 쓰레드에 설정한 뒤 반환한다.
즉, 이 함수의 호출은 코루틴의 실행을 위해 이벤트 루프를 준비하는 과정으로 볼 수 있다.

아래는 이벤트를 실행 했을 시의 대략적인 의사 
코드다.
```python
while True:
	if callback_queue:
		task = callback_queue.pop()
		task.run()
	else:
		check_is_IO_ready()
```
### 2. loop.run_until_complete(first_coroutine())
앞서 생성한 이벤트 루프 객체를 이용하여 실제로 이벤트 루프를 실행시키는 함수

#### 2-1. 코루틴 체인의 형성
인자로 넘어오는 코루틴 객체를 이용하여 태스크 객체를 생성한다.
 
그 과정에서 해당 태스크 객체가 나타내는 태스크의 실행이 이벤트 루프에 의해 즉시 예약된다.


처음에는 예약된 다른 태스크가 없으므로 이벤트 루프는 이 태스크를 바로 실행할 것이다.

이때 태스크의 실행이란 해당 태스크 객체의 `__step()`를 호출하는 것을 의미한다.
`__step()`은 코루틴 객체의 `send()`를 호출함으로써 해당 코루틴을 실행하는 역할이다.

이 코루틴을 시작으로 `await`를 마주할 때마다 연쇄적으로 코루틴을 호출하여 코루틴 체인을 형성하게 된다.
#### 2-2. 코루틴 체인의 종착점(await)

코루틴들은 퓨쳐 객체를 `await`하도록 구현되어 있다.

일례로 I/O 관련 코루틴인 경우,

소켓의 상태를 검사하여 당장 읽거나 쓸 수 있는 데이터가 있다면 
단순히 `yield`만을 이용하여 태스크 객체의 `__step()`메서드로 제어를 넘긴다.

그러나 당장 읽거나 쓸 수 있는 데이터가 있지 않다면
`select()`를 이용하여 해당 소켓을 등록해두고, 해당 소켓에 바인딩된 퓨처 객체를 새로 생성하여 `await`한다.

`__await__()` 메서드는 자기 자신(퓨쳐 객체)을 `yield` 하도록 구현되어 있기 때문에 

이로 인해 해당 퓨쳐 객체는 코루틴 체인을 따라 태스크 객체의 `__step()` 메서드로 전달될 것이다.


#### 2-3. 태스크 객체의 퓨쳐 객체 처리
태스크 객체는 `yield`된 퓨쳐 객체를 받으면 이것을 자신의 `__fut_waiter`필드에 바인딩(저장)한다.

퓨처 객체의 `add_done_callback()`메서드를 호출하여 
완료 상태가 될 때 이벤트 루프에게 실행을 예약할 콜백 함수를 등록한다.

태스크 객체는 자신의 실행을 중단하고 제어를 이벤트 루프에게 넘긴다.
#### 2-4. 이벤트 루프의 Polling(I/O 소켓 검사)