해당 이슈는 PyMySQL 1.1.0v 에서 발생한 것으로, SQL 인젝션 취약점이다.

먼저 다음과 같은 테이블이 있다고 가정해보자.

| 테이블  | 이름       | 타입      |
| ---- | -------- | ------- |
| user | id       | BIGINT  |
|      | name     | VARCHAR |
|      | password | VARCHAR |
| post | id       | BIGINT  |
|      | user_id  | BIGINT  |
|      | content  | VARCHAR |
|      | title    | VARCHAR |


취약한 코드는 다음과 같다.
```python
from sqlalchemy import text


async def findById(session, id: str):  
    try:  
        with session.begin():  
            sql = text(f"SELECT * FROM post WHERE id = {id}")  
            result = session.execute(sql).fetchall()   
            return result
    except Exception as e:  
        session.rollback()  
        raise e  
    finally:  
        session.close()
```

안전한 코드
```python
from sqlalchemy import text


async def findById(session, id: str):  
    try:  
        with session.begin():  
            sql = text(f"SELECT * FROM post WHERE id = :id")  
            result = session.execute(sql, ({"id": id})).fetchall()   
            return result
    except Exception as e:  
        session.rollback()  
        raise e  
    finally:  
        session.close()
```

보기만해선 모르겠으니 직접 해보도록 하자.
id는 모두 "1 or 1=1"을 넣어준다. (or과 함께 1=1이므로 Where문은 모든 row에 대해 True이다)

취약한 코드일 때
```json
{
	"data": [
		{
			"id": 1,
			"user_id": 1,
			"content": "name_1",
			"title": "1"
		},
		{
			"id": 2,
			"user_id": 1,
			"content": "123141241",
			"title": "1_2"
		},
		{
			"id": 3,
			"user_id": 2,
			"content": "asdasfaf",
			"title": "2"
		}
	]
}
```

안전한 코드일때
```json
{
	"data": [
		{
			"id": 1,
			"user_id": 1,
			"content": "name_1",
			"title": "1"
		}
	]
}
```
위와 같이 취약한 코드는 모든 row를 다 보여주고 안전한 코드는 의도한 대로 id = 1인 row만 보여준다.

심지어는
"1 UNION SELECT id, 1, name, password, FROM user" 인자로 전달하면
```json
{
	"data": [
		{
			"id": 1,
			"user_id": 1,
			"content": "name_1",
			"title": "1"
		},
		{
			"id": 1, // 유저 식별값
			"user_id": 1, // 더미 값
			"content": "아이디", // 아이디
			"title": "패스워드" // 비밀번호
		},
		{
			"id": 2, // 유저 식별값
			"user_id": 1, // 더미 값
			"content": "아이디", // 아이디
			"title": "패스워드" // 비밀번호
		}
	]
}
```
이런식으로 출력된다.

설명을 덧붙이면 id, name, password 사이에  1을 넣는 것은 post테이블과 UNION SELECT 하기위해
테이블 형태를 도메인을 맞춰주는 것이다.

post는 (BIGINT, BIGINT, VARCHAR, VARCHAR)의 형태이므로 (BIGINT, VARCHAR, VARCHAR)형태인
user 테이블과 UNION SELECT하기 위해서는 1을 넣으므로써 도메인 형태를 같게 한다.

또 대부분의 id는 auto increment로 unsigned인 점을 이용하면
```json
{
	"data": [
		{
			"id": 1, // 유저 식별값
			"user_id": 1, // 더미 값
			"content": "아이디", // 아이디
			"title": "패스워드" // 비밀번호
		},
		{
			"id": 2, // 유저 식별값
			"user_id": 1, // 더미 값
			"content": "아이디", // 아이디
			"title": "패스워드" // 비밀번호
		}
	]
}
```
위 처럼 유저 정보만 빼돌릴 수 있다.

단순히 게시물을 조회하는 로직에서 모든 유저의 정보를 빼돌릴 수 있는 셈이다.

### 취약한 코드와 안전한 코드의 차이점
두 코드의 차이점이 무엇이길래 하나는 SQL Injection이 가능하고 하나는 불가능 할까?

취약한 코드는 `f"{}"`를 사용해 직접 쿼리에 문자열로 넣었지만
안전한 코드는 :id를 사용한뒤 쿼리 파라미터로 전달했다.

파라미터화된 쿼리는 SQL 쿼리 문자열과 입력값을 분리하여 어떤 입력값을 제공해도 SQL 구조 자체가 변조되지는 않는다.