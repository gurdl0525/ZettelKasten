해당 이슈는 PyMySQL 1.1.0v 에서 발생한 것으로, SQL 인젝션 취약점이다.

먼저 다음과 같은 테이블이 있다고 가정해보자.

| 테이블  | 이름       | 타입      |
| ---- | -------- | ------- |
| user | id       | BIGINT  |
|      | name     | VARCHAR |
|      | password | VARCHAR |
| post | id       | BIGINT  |
|      | user_id  | BIGINT  |
|      | content  | VARCHAR |
|      | title    | VARCHAR |


취약한 코드는 다음과 같다.
```python
from sqlalchemy import text


async def findById(session, id: str):  
    try:  
        with session.begin():  
            sql = text(f"SELECT * FROM post WHERE id = {id}")  
            result = session.execute(sql).fetchall()   
            return result
    except Exception as e:  
        session.rollback()  
        raise e  
    finally:  
        session.close()
```

안전한 코드
```python
from sqlalchemy import text


async def findById(session, id: str):  
    try:  
        with session.begin():  
            sql = text(f"SELECT * FROM post WHERE id = :id")  
            result = session.execute(sql, ({"id": id})).fetchall()   
            return result
    except Exception as e:  
        session.rollback()  
        raise e  
    finally:  
        session.close()
```

보기만해선 모르겠으니 직접 해보도록 하자.
id는 모두 "1 or 1=1"을 넣어준다. (or과 함께 1=1이므로 Where문은 모든 row에 대해 True이다)

취약한 코드일 때
```json
{
	"data": [
		{
			"id": 1,
			"user_id": 1,
			"content": "name_1",
			"title": "1"
		},
		{
			"id": 2,
			"user_id": 1,
			"content": "123141241",
			"title": "1_2"
		},
		{
			"id": 3,
			"user_id": 2,
			"content": "asdasfaf",
			"title": "2"
		}
	]
}
```

안전한 코드일때
```json
{
	"data": [
		{
			"id": 1,
			"user_id": 1,
			"content": "name_1",
			"title": "1"
		}
	]
}
```
위와 같이 취약한 코드는 모든 row를 다 보여주고 안전한 코드는 의도한 대로 id = 1인 row만 보여준다.

심지어는
"1 UNION SELECT id, 1, name, password, FROM user" 인자로 전달하면
```json
{
	"data": [
		{
			"id": 1,
			"user_id": 1,
			"content": "name_1",
			"title": "1"
		},
		{
			"id": 1, // 유저 식별값
			"user_id": 1, // 더미 값
			"content": "아이디", // 아이디
			"title": "패스워드" // 비밀번호
		},
		{
			"id": 2, // 유저 식별값
			"user_id": 1, // 더미 값
			"content": "아이디", // 아이디
			"title": "패스워드" // 비밀번호
		}
	]
}
```
이런식으로 출력된다.

설명을 덧붙이면 id, name, password 사이에  1을 넣는 것은 post테이블과 UNION SELECT 하기위해
테이블 형태를 도메인을 맞춰주는 것이다.

post는 (BIGINT, BIGINT, VARCHAR, VARCHAR)의 형태이므로 (BIGINT, VARCHAR, VARCHAR)형태인
user 테이블과 UNION SELECT하기 위해서는 1을 넣으므로써 도메인 형태를 같게 한다.

또 대부분의 id는 auto increment로 unsigned인 점을 이용하면
```json
{
	"data": [
		{
			"id": 1, // 유저 식별값
			"user_id": 1, // 더미 값
			"content": "아이디", // 아이디
			"title": "패스워드" // 비밀번호
		},
		{
			"id": 2, // 유저 식별값
			"user_id": 1, // 더미 값
			"content": "아이디", // 아이디
			"title": "패스워드" // 비밀번호
		}
	]
}
```
위 처럼 유저 정보만 빼돌릴 수 있다.

단순히 게시물을 조회하는 로직에서 모든 유저의 정보를 빼돌릴 수 있는 셈이다.

### 취약한 코드와 안전한 코드의 차이점
두 코드의 차이점이 무엇이길래 하나는 SQL Injection이 가능하고 하나는 불가능 할까?

취약한 코드는 `f"{}"`를 사용해 직접 쿼리에 문자열로 넣었지만
안전한 코드는 :id를 사용한뒤 쿼리 파라미터로 전달했다.

파라미터화된 쿼리는 SQL 쿼리 문자열과 입력값을 분리하여 어떤 입력값을 제공해도 SQL 구조 자체가 변조되지는 않는다.

### PyMYSQL만 그럴까?

JPA도 가능하다.
```java
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import org.springframework.stereotype.Repository;

@Repository
public class UserRepository {

    @PersistenceContext
    private EntityManager entityManager;

    public User findUserByName(String name) {
        // SQL Injection 가능성이 있는 취약한 코드
        String queryString = "SELECT u FROM User u WHERE u.name = '" + name + "'";
        Query query = entityManager.createQuery(queryString);
        return (User) query.getSingleResult();
    }
}
```

TypeORM도 가능하다.
```typescript
import { EntityRepository, Repository } from 'typeorm';
import { User } from './user.entity';

@EntityRepository(User)
export class UserRepository extends Repository<User> {

    async findUserByName(name: string): Promise<User | undefined> {
        // SQL Injection 가능성이 있는 취약한 코드
        return await this.query(`SELECT * FROM user WHERE name = '${name}'`);
    }
}
```

해당 ORM들을 대부분 직접 query를 짜는 대신 QueryDSL, QueryBuilder같은 대체 가능한 확장 라이브러리가 있기 때문에 해당 방법을 권장한다.

하지만 이글을 적는 나도 JPA를 사용할 떄 native query를 사용하는 경우가 잦았기 때문에 앞으로